// 1. webpack是做什么用的？
//webpack是前端的一种模块化打包(构建)工具,他做的事是分析项目结构,找到js模块，浏览器无法识别的一些拓展语言(Sass,Less)，新的语法等，将其转换并打包成浏览器能识别的语法
//webpack可以用来将Sass，Less转换成Css供浏览器使用；将项目中的各个模块整合起来，减少HTTP请求次数，压缩打包后的代码；部分ES6的语法兼容有问题，转换成ES5的语法
//entry(入口):要打包哪里的文件  output(出口):要打包到哪里  loader(加载器):加载JS以外的文件  plugins(插件):处理loader完成不了的功能，使用插件 


// 2. 在发送请求时对请求进行终止？
//fetch是HTTP原生数据请求方式，创建AbortController对象，使用signal生成关联变量添加到fetch请求参数中，在想要中断的时候使用abort方法
//控制器不能多次使用，如果一旦终止就要取消所有，如果不想取消所有，就需要创建多个控制器，请求的取消仅发生在前端，后端仍会进行处理
//promise.race会让请求挂起，不会取消请求
//const controller = new AbortController()
//function download() {
//     fetch('https://jsonplaceholder.typicode.com/todos/1',{
//         signal: controller.signal
//     })
//       .then(response => response.json())
//       .then(json => console.log(json)) 
// }
//download()
//controller.abort();

// const CancelToken = axios.CancelToken;
// const source = CancelToken.source();
// axios.get('/user/12345', {
//     cancelToken: source.token,
// })

// 3. 单点登录，多点登录的理解？
//单点登录：在一个多系统共存的环境下，用户在一处登录后，不用在其他系统中登录
//多点登录：多个端同时登录一个账号，同时收发消息，需要在服务端存储同一个用户多个端的状态与登陆点，发消息时，要对发送方的多端与接收端的多端都进行消息投递

//单点登陆的三种实现方式
// 1、session广播机制:每个节点的session状态都被复制到集群中的其他所有节点，只要session发生改变，数据都要重新复制
//      优点：每个节点都复制一份session,一个节点出现问题其他节点可以接替工作
//      缺点：节点间进行session同步会占据不少系统资源，整体性能会随着节点数增加而急剧下降
// 2、cookie+redis
//      系统先将用户登录信息存入redis中，key值是生成的唯一值(可以包括IP，用户id,UUID等)，value值存放用户登录信息
//      系统将用户在redis中的key值存入该用户的cookie中，每次访问任意模块都会带着这个cookie
//      其他模块处理用户请求时，先获取用户cookie中的key值，然后将key值拿到redis中查询，如果能查到就说明用户已登录
// 3、token：按照一定规则生成的包含用户信息的字符串(可以使用JWT自动生成),生成后可以通过cookie返回，也可以通过地址栏返回
// 单点登录优缺点
//      优点：提高用户效率，不用记住多个ID和密码; 提高开发人员的效率，SSO机制独立，开发人员完全不需要为身份验证操心; 简化管理，管理用户账户的负担就会减轻
//      缺点：涉及系统很多，重构耗时，因为只需要登录一次，所有授权的应用系统都可以访问，可能会导致一些

// 4. 浏览器seo优化  网络蜘蛛会在每个网站节点上爬取关键词存入数据库
//概念：通过搜索引擎的规则来优化，提升网页在搜索引擎中的权重，从而提高产品的排名，以获得流量曝光和品牌收益
//优化方法：
//  1、网站结构布局优化
//      控制首页链接数量，不可过少也不可过多
//      扁平化目录层次，尽量让“网路蜘蛛”只跳转三次就能到达网站内任何一页
//      导航优化，尽量采用文字方式，也可搭配图片导航，img标签必须添加alt(图片无法显示的时候显示，利于seo)和title(鼠标悬停图片显示，利于用户体验)属性,
//          加上面包屑，帮助用户很快了解网站组织形式，方便用户操作，有利于蜘蛛清楚了解网站结构，增加大量内部链接，方便抓取
//      网站结构布局清晰易读
//          头部：logo及主导航，以及用户信息
//          主体：左边正文和面包屑导航，右边放热门文章及相关文章
//          底部：版权信息和友情链接
//      重要内容放在最前
//      控制页面文件大小，减少http请求，提高网站加载速度
//  2、网页代码优化
//      合理设计title，description，keywords
//      语义化书写HTML代码，符合W3C标准
//      页内连接，加上“title”属性加以说明，让访客和蜘蛛了解链接用途，外部链接需要加上rel="nofollow"属性，高速蜘蛛不要爬，否则进入外部链接之后不会再回来了
//      尽量少使用iframe框架，蜘蛛一般不会读取里面内容
//      重要内容不使用JS进行输出，蜘蛛不会读取js内容，谨慎使用display:none，搜索引擎会过滤掉display:none其中内容
//      精简代码，降低相同代码重复次数，删除累赘代码
// 网站性能优化
//  1、减少http请求次数，
//      请求数量超过浏览器允许的并发数，资源请求存在等待状态，导致网页很长时间无法正常展示
//      使用精灵图
//      合并CSS和JS文件
//      采用懒加载
//  2、控制资源文件加载优先级，因为从上至下解析HTML内容，需要将CSS提前加载
//  3、将CSS，JS分离出HTML，使用外链加载
//  4、浏览器缓存
//  5、减少重排，DOM操作
//  6、使用字体图标
//  7、不使用CSS表达式(expression)
//  8、使用CDN网络缓存，加快访问速度，减轻服务器压力
//  9、使用GZIP压缩，加快浏览器速度

// 5. restful和普通接口有什么区别？
// restful接口是一种架构设计风格，提供了设计原则和约束条件，简洁又层次，更易于实现缓存等机制。同一个URL，根据method请求行为不同，后端处理不同内容

// 6. ES6的导入导出的了解？

//  默认导入导出    
//export default { name: "张三", age: 18 }
//import obj from 地址
//import { name, age as Age } from 地址
//console.log(obj) //{ name: "张三", age: 18 }

//  按需导入导出    
//export const name = "张三" 
//export const age = 18
//console.log(name, Age) //张三 18

//默认导出与整体导出一起使用
//export default { name: "张三", age: 18 }
//export const sex = "男"
//import obj, { sex } from 地址
//console.log(obj,sex)  { name: "张三", age: 18 }  男


// js模块
// 7. 闭包的理解及应用场景，内存泄漏的理解及应对方法？
// 理解：嵌套函数，内部函数引用了外部变量。由于内部函数没有执行完成，外部函数变量不会被销毁，资源没有得到释放，形成闭包
// 应用场景： 
//      1、柯里化函数，高阶函数，将一个多参数函数转化为一个单参数函数
//      2、通过闭包实现变量/方法的私有化
//      3、匿名自执行函数
//      4、缓存一些结果
// 内存泄漏的理解：闭包不会引起内存泄漏，只是由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集，闭包的作用域链中保存着一个HTML元素，意味着该元素无法被销毁
//      闭包造成的内存泄露是旧版本IE的bug，真正情况下的闭包不会造成内存泄露
// 应对方法：闭包使得函数中的变量都被保存在内存中，内存消耗很大，不能滥用闭包，否则会造成网页的性能问题，在IE中导致内存泄露，在退出函数中之前，将不使用的局部变量全部删除
//          不要随便更改父函数内部变量的值

// 8. 原型链的理解？
//js分为「函数对象」和「普通对象」，每个对象都有__proto__属性(饮食原型，浏览器环境会部署该属性，其他运行环境可能不存在，尽量不使用该属性，
//可以用getPrototypeOf()和setPrototypeOf()代替)，但是只有函数对象且「非箭头函数」才有prototype属性(显示原型，指向原型对象)，
//每个原型都有一个constructor属性，指向该关联的构造函数

//                 Prototype 
//Person(构造函数) ------------>  Person.prototype(实例原型)
//  |             <-----------           🔼
//  | new          constructor           | __proto__
//  🔽                                   |
// person(实例)  -------------------------

//实例对象的__proto__指向其构造函数的prototype，从而实现继承，


// 9. js中的深拷贝和浅拷贝的理解？
// 10. js数组去重，求和，数组字符串类型转换，数据类型判断typeOf等，join，split方法等的了解？
// 11. 手写ajax请求过程？
// 12. ajax和axios、fetch的区别？
// 13. 回调函数，Promise，async await的区别及理解?
// 14. DOM，BOM对象？
// 15. cookie和session，localStorage，sessionStorage区别和理解及数据缓存相关概念？
// 16. 事件冒泡的理解？
// 17. 节流阀的了解？
// 18. ES6比较ES5最大的改变是什么，按需导入等，增加哪些东西？
// 19. 浏览器JavaScript的宏任务和微任务的了解？

// 页面布局及样式选择器模块
// 20. 水平垂直居中的几种实现方法
// 21. 两端固定，中间自适应布局实现方式？
// 22. flex，rem响应式布局
// 23. 清除浮动的了解？
// 24. jquery中的样式选择器
// 25. 伪类，伪元素的了解？

// 微信小程序模块
// 26. 无限页面跳转，最多跳转多少次？ wx.navigateTo小程序中页面栈最多10层。
// 27. em rem vh vw rpx 的区别和理解？
// 28. app.js的回调函数在页面中调用，解决数据加载问题？
// 29. 微信小程序ios端下拉弹簧问题 页面json配置disablescorll属性
// 30. 小程序中canvas和原生组件在小程序里层级问题
// 31. 小程序的分包使用？
// 32. scorllView底部上下滑动，触及界限问题？

// vue模块
// 33. 数据双向绑定和微信小程序的双向绑定的区别和理解
// 34. v-if和v-for的层级比较
// 35. Vue中的key值的作用
// 36. 路由导航，登录拦截等
// 37. 自定义属性实现思路
// 38. 对Vue生命周期的8个钩子函数的理解？
// 39. Vue的设计模式，MVVM和MVC的区别？
// 40. Vue组件通信几种
// 41. Vue中的计算属性，监听器，及methods方法理解
// 42. Vuex的组成及理解
// 43. keep-alive的理解
// 44. 对公共数据的使用， 为什么不放在 gloab或者本地？因为Vuex 响应式 ，，数据驱动视图
// 45. Vue的性能优化有哪些？
// 46. Vue的虚拟dom了解？
// 47. namespace命名空间的理解